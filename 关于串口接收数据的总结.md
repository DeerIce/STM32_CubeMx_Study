### **关于串口接收数据的总结**

1. #### HAL_UART_Receive

   - 超时模式接收

   - 不会进入中断（经实验发现未进入中断）

   - 个人理解：在设定时间内，接收到多少就是多少（当然最多也不能超出设置的长度）

2. #### HAL_UART_Receive_IT

   - ##### 中断模式接收

   - 每接收1bit字符就进入一次中断函数：USART1_IRQHandler，当接收完指定长度的字符串后关闭中断，之后不能再进入中断，需要用户重新使能。

3. #### HAL_UART_Receive_DMA

   - ##### DMA模式接收

     - 普通DMA中断：

       传输一半触发一次、传输完成触发一次

       uint8_t RX_Array[32] = "";

       每次发送4bits，发送16bits触发一次(半中断)，发送到32bits时又触发一次(全中断)![image-20230405205201499](C:\Users\80584\AppData\Roaming\Typora\typora-user-images\image-20230405205201499.png)

       

     - DMA+空闲中断：

       现象：

       ![image-20230405222435665](C:\Users\80584\AppData\Roaming\Typora\typora-user-images\image-20230405222435665.png)

### **总结：**

- 直接用串口中断接收数据会导致进入中断的次数过多，效率低下，所以选择DMA模式。

- 如果仅仅使用DMA接收数据，只会在接收到指定长度或一半时进入DMA中断（不是串口中断）。

- 如果使用串口空闲中断，则能灵活接收数据（即不定长度），但最大长度也不能超过设定值，否则就存不下了；

  且触发的是串口中断，如果不对DMA进行操作的话，后续也会进入DMA中断；

  如果在串口中断中重置DMA，之后就不会进入DMA中断，一般都会重置。

个人观点：使用DMA搬运数据时，是否串口空闲中断影响的不是效率，而是效果。

​					DMA搬运数据本就不需要CPU的干涉，没有效率之说。使用空闲中断的好处就是不用提前知道接收数据的长度，在1个字节长度的时间内没有新的数据到来，就能够及时进入中断处理先前接收到的数据。